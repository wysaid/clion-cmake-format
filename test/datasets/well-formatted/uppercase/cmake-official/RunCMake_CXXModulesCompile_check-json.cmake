FUNCTION(json_placeholders in out)
    STRING(REPLACE "<CONFIG>" "${CXXModules_config}" in "${in}")
    STRING(TOLOWER "${CXXModules_config}" config_lower)
    STRING(REPLACE "<CONFIG_LOWER>" "${config_lower}" in "${in}")
    STRING(REPLACE "<CONFIG_OTHER>" "${CXXModules_config_other}" in "${in}")
    STRING(TOLOWER "${CXXModules_config_other}" config_lower)
    STRING(REPLACE "<CONFIG_OTHER_LOWER>" "${config_lower}" in "${in}")
    IF (RunCMake_GENERATOR_IS_MULTI_CONFIG)
        STRING(REPLACE "<CONFIG_DIR>" "/${CXXModules_config}" in "${in}")
        STRING(REPLACE "<CONFIG_OTHER_DIR>" "/${CXXModules_config_other}" in "${in}")
    ELSE ()
        STRING(REPLACE "<CONFIG_DIR>" "" in "${in}")
        STRING(REPLACE "<CONFIG_OTHER_DIR>" "" in "${in}")
    ENDIF ()
    IF (CMAKE_BUILD_TYPE)
        STRING(REPLACE "<CONFIG_FORCE>" "${CXXModules_config}" in "${in}")
        STRING(REPLACE "<CONFIG_OTHER_FORCE>" "${CXXModules_config_other}" in "${in}")
    ELSE ()
        STRING(REPLACE "<CONFIG_FORCE>" "noconfig" in "${in}")
    ENDIF ()
    STRING(REPLACE "<SOURCE_DIR>" "${RunCMake_SOURCE_DIR}" in "${in}")
    STRING(REPLACE "<BINARY_DIR>" "${RunCMake_TEST_BINARY_DIR}" in "${in}")
    STRING(REPLACE "<OBJEXT>" "${CMAKE_CXX_OUTPUT_EXTENSION}" in "${in}")
    IF (CMAKE_CXX_MODULE_MAP_FORMAT STREQUAL "gcc")
        SET(bmiflag "-fmodule-only")
        SET(bmiext "gcm")
    ELSEIF (CMAKE_CXX_MODULE_MAP_FORMAT STREQUAL "clang")
        SET(bmiflag "--precompile")
        SET(bmiext "pcm")
    ELSEIF (CMAKE_CXX_MODULE_MAP_FORMAT STREQUAL "msvc")
        SET(bmiflag "-ifcOutput.*")
        SET(bmiext "ifc")
    ENDIF ()
    STRING(REPLACE "<BMI_ONLY_FLAG>" "${bmiflag}" in "${in}")
    STRING(REPLACE "<BMIEXT>" ".${bmiext}" in "${in}")
    SET(output_flag "-o")
    IF (CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL "MSVC")
        SET(output_flag "-Fo")
    ENDIF ()
    STRING(REPLACE "<OUTPUT_FLAG>" "${output_flag}" in "${in}")
    STRING(REPLACE "<CXX20_OPTION>" "${CMAKE_CXX20_STANDARD_COMPILE_OPTION}" in "${in}")
    STRING(REPLACE "<HEX>" "[0-9a-f]+" in "${in}")
    STRING(REPLACE "REGEX:" "" in "${in}")
    STRING(REPLACE "PATH:" "" in "${in}")
    SET("${out}" "${in}" PARENT_SCOPE)
ENDFUNCTION()

FUNCTION(check_json_value path actual_type expect_type actual_value expect_value)
    IF (NOT actual_type STREQUAL expect_type)
        STRING(APPEND RunCMake_TEST_FAILED
            "Type mismatch at:\n ${path}\nexpected:\n ${expect_type}\nactual:\n ${actual_type}\n")
        SET(RunCMake_TEST_FAILED "${RunCMake_TEST_FAILED}" PARENT_SCOPE)
        RETURN()
    ENDIF ()

    IF (actual_type STREQUAL NULL)
        # Nothing to check
    ELSEIF (actual_type STREQUAL BOOLEAN)
        IF (NOT actual_value STREQUAL expect_value)
            STRING(APPEND RunCMake_TEST_FAILED
                "Boolean mismatch at:\n ${path}\nexpected:\n ${expect_value}\nactual:\n ${actual_value}\n")
        ENDIF ()
    ELSEIF (actual_type STREQUAL NUMBER)
        IF (NOT actual_value EQUAL expect_value)
            STRING(APPEND RunCMake_TEST_FAILED
                "Number mismatch at:\n ${path}\nexpected:\n ${expect_value}\nactual:\n ${actual_value}\n")
        ENDIF ()
    ELSEIF (actual_type STREQUAL STRING)
        # Allow some values to be ignored.
        IF (expect_value STREQUAL "<IGNORE>")
            RETURN()
        ENDIF ()

        JSON_PLACEHOLDERS("${expect_value}" expect_value_expanded)
        IF (expect_value MATCHES "^REGEX:PATH:")
            STRING(REPLACE "\\" "/" actual_value_check "${actual_value}")
            STRING(REGEX REPLACE "^\"(.*)\"$" "\\1" actual_value_check "${actual_value_check}")
            IF (NOT actual_value_check MATCHES "^${expect_value_expanded}$")
                STRING(APPEND RunCMake_TEST_FAILED
                    "String mismatch (path regex) at:\n ${path}\nexpected:\n ^${expect_value_expanded}$\nactual:\n ${actual_value}\n")
            ENDIF ()
        ELSEIF (expect_value MATCHES "^REGEX:")
            IF (NOT actual_value MATCHES "^${expect_value_expanded}$")
                STRING(APPEND RunCMake_TEST_FAILED
                    "String mismatch (regex) at:\n ${path}\nexpected:\n ^${expect_value_expanded}$\nactual:\n ${actual_value}\n")
            ENDIF ()
        ELSEIF (expect_value MATCHES "^PATH:")
            STRING(REPLACE "\\" "/" actual_value_check "${actual_value}")
            STRING(REGEX REPLACE "^\"(.*)\"$" "\\1" actual_value_check "${actual_value_check}")
            IF (NOT actual_value_check STREQUAL "${expect_value_expanded}")
                STRING(APPEND RunCMake_TEST_FAILED
                    "String mismatch (path) at:\n ${path}\nexpected:\n ${expect_value_expanded}\nactual:\n ${actual_value}\n")
            ENDIF ()
        ELSEIF (NOT actual_value STREQUAL expect_value_expanded)
            STRING(APPEND RunCMake_TEST_FAILED
                "String mismatch at:\n ${path}\nexpected:\n ${expect_value_expanded}\nactual:\n ${actual_value}\n")
        ENDIF ()
    ELSEIF (actual_type STREQUAL ARRAY)
        CHECK_JSON_ARRAY("${path}" "${actual_value}" "${expect_value}")
    ELSEIF (actual_type STREQUAL OBJECT)
        CHECK_JSON_OBJECT("${path}" "${actual_value}" "${expect_value}")
    ENDIF ()

    SET(RunCMake_TEST_FAILED "${RunCMake_TEST_FAILED}" PARENT_SCOPE)
ENDFUNCTION()

# Check that two arrays are the same.
FUNCTION(check_json_array path actual expect)
    IF (item_filter)
        STRING(JSON iter_len LENGTH "${actual}")
        SET(idx 0)
        WHILE (idx LESS iter_len)
            STRING(JSON type TYPE "${actual}" "${idx}")
            STRING(JSON item GET "${actual}" "${idx}")
            IF (type STREQUAL "STRING" AND
                item MATCHES "${item_filter}")
                STRING(JSON actual REMOVE "${actual}" "${idx}")
                MATH(EXPR iter_len "${iter_len} - 1")
            ELSE ()
                MATH(EXPR idx "${idx} + 1")
            ENDIF ()
        ENDWHILE ()
    ENDIF ()

    STRING(JSON actual_len LENGTH "${actual}")
    STRING(JSON expect_len LENGTH "${expect}")

    SET(iter_len "${actual_len}")
    IF (actual_len LESS expect_len)
        STRING(APPEND RunCMake_TEST_FAILED
            "Missing array items at:\n ${path}\n")
    ELSEIF (expect_len LESS actual_len)
        STRING(APPEND RunCMake_TEST_FAILED
            "Extra array items at:\n ${path}\n")
        SET(iter_len "${expect_len}")
    ENDIF ()

    FOREACH (idx RANGE "${iter_len}")
        IF (idx EQUAL iter_len)
            BREAK ()
        ENDIF ()

        SET(new_path "${path}[${idx}]")
        STRING(JSON actual_type TYPE "${actual}" "${idx}")
        STRING(JSON expect_type TYPE "${expect}" "${idx}")
        STRING(JSON actual_value GET "${actual}" "${idx}")
        STRING(JSON expect_value GET "${expect}" "${idx}")
        CHECK_JSON_VALUE("${new_path}" "${actual_type}" "${expect_type}" "${actual_value}" "${expect_value}")
    ENDFOREACH ()

    SET(RunCMake_TEST_FAILED "${RunCMake_TEST_FAILED}" PARENT_SCOPE)
ENDFUNCTION()

# Check that two inner objects are the same.
FUNCTION(check_json_object path actual expect)
    STRING(JSON actual_len LENGTH "${actual}")
    STRING(JSON expect_len LENGTH "${expect}")

    SET(actual_keys "")
    SET(expect_keys "")
    FOREACH (idx RANGE "${actual_len}")
        IF (idx EQUAL actual_len)
            BREAK ()
        ENDIF ()

        STRING(JSON actual_key MEMBER "${actual}" "${idx}")
        LIST(APPEND actual_keys "${actual_key}")
    ENDFOREACH ()
    FOREACH (idx RANGE "${expect_len}")
        IF (idx EQUAL expect_len)
            BREAK ()
        ENDIF ()

        STRING(JSON expect_key MEMBER "${expect}" "${idx}")
        LIST(APPEND expect_keys "${expect_key}")
    ENDFOREACH ()

    JSON_PLACEHOLDERS("${expect_keys}" expect_keys_expanded)

    SET(actual_keys_missed "${actual_keys}")
    SET(expect_keys_missed "${expect_keys}")

    SET(common_keys "")
    SET(expect_keys_stack "${expect_keys}")
    WHILE (expect_keys_stack)
        LIST(POP_BACK expect_keys_stack expect_key)
        JSON_PLACEHOLDERS("${expect_key}" expect_key_expanded)

        IF (expect_key_expanded IN_LIST actual_keys_missed AND
            expect_key IN_LIST expect_keys_missed)
            LIST(APPEND common_keys "${expect_key}")
        ENDIF ()

        LIST(REMOVE_ITEM actual_keys_missed "${expect_key_expanded}")
        LIST(REMOVE_ITEM expect_keys_missed "${expect_key}")
    ENDWHILE ()

    IF (actual_keys_missed)
        STRING(REPLACE ";" ", " actual_keys_missed_text "${actual_keys_missed}")
        STRING(APPEND RunCMake_TEST_FAILED
            "Extra unexpected members at:\n ${path}\nactual:\n ${actual_keys_missed_text}\n")
    ENDIF ()
    IF (expect_keys_missed)
        STRING(REPLACE ";" ", " expect_keys_missed_text "${expect_keys_missed}")
        STRING(APPEND RunCMake_TEST_FAILED
            "Missing expected members at\n ${path}\nactual:\n ${expect_keys_missed_text}\n")
    ENDIF ()

    FOREACH (key IN LISTS common_keys)
        JSON_PLACEHOLDERS("${key}" key_expanded)
        SET(new_path "${path}.${key_expanded}")
        STRING(JSON actual_type TYPE "${actual}" "${key_expanded}")
        STRING(JSON expect_type TYPE "${expect}" "${key}")
        STRING(JSON actual_value GET "${actual}" "${key_expanded}")
        STRING(JSON expect_value GET "${expect}" "${key}")
        CHECK_JSON_VALUE("${new_path}" "${actual_type}" "${expect_type}" "${actual_value}" "${expect_value}")
    ENDFOREACH ()

    SET(RunCMake_TEST_FAILED "${RunCMake_TEST_FAILED}" PARENT_SCOPE)
ENDFUNCTION()

# Check that two JSON objects are the same.
FUNCTION(check_json actual expect)
    CHECK_JSON_OBJECT("" "${actual}" "${expect}")

    SET(RunCMake_TEST_FAILED "${RunCMake_TEST_FAILED}" PARENT_SCOPE)
ENDFUNCTION()
